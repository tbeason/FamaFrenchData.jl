"""
Julia package for easy access to the Ken French Data Library files. See `readFamaFrench`
"""
module FamaFrenchData

using HTTP
using CSV
using ZipFile
using DataFrames
import Dates: now



export readFamaFrench, downloadFamaFrench, listFamaFrench

const KFDLftp = "http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/ftp/"

"""
`readFamaFrench(ffn;kwargs...)`

`ffn` can be the table name (in which case it is retreived from the web) or a path to the local file.
`kwargs` are passed to `CSV.read`. Missing values (`-99.99` or `-999`) are replaced with `missing`.

Returns three pieces:

    - `tables::Vector{DataFrame}` - the extracted tables

    - `tablenotes::Vector{String}` - any notes to the 
    
    - `filenotes::String` - notes at the top of the file
"""
function readFamaFrench(ffn;kwargs...)
    if !isfile(ffn)
        io = IOBuffer(HTTP.get(pathtoFamaFrench(ffn)).body)
        z = ZipFile.Reader(io)
        ff = first(z.files)
    else
        ff = open(ffn)
    end
    tables, tablenotes, filenotes = parsefile(ff;kwargs...)
    close(ff)
    return tables, tablenotes, filenotes
end




"""
`downloadFamaFrench(savename,ffn)`

Saves the extracted CSV file from `ffn` to local file `savename`.
"""
function downloadFamaFrench(savename,ffn)
    open(savename,"w") do f
        io = IOBuffer(HTTP.get(pathtoFamaFrench(ffn)).body)
        z = ZipFile.Reader(io)
        ff = first(z.files)
        for s in readlines(ff)
            println(f,s)
        end
        close(ff)
    end
end




"""
`listFamaFrench(;refresh=false)`

Returns a vector of possible table names. Reads from `listFamaFrench.txt`.
When `refresh = true`, first crawls the website to find current list of tables, then overwrites `listFamaFrench.txt` with this list.
The selection of tables is rarely changed, so the provided list is likely sufficient.
"""
function listFamaFrench(;refresh = false)
    LFF_file = abspath(joinpath(@__DIR__, "..", "listFamaFrench.txt"))
    if refresh
        # grabs filenames from website
        wname  = "https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html" 
        hs=String(HTTP.request("GET",wname).body)
        regx = r"(?<=ftp\/)(.*)(?=_CSV)"
        res=collect(eachmatch(regx,hs)) 
        nms = getfield.(res,:match)
        # writes the available filenames to a file
        rm(LFF_file)
        open(LFF_file,"w") do f
            println(f,"# Generated by FamaFrenchData.jl $(now())")
            for s in nms
                println(f,s)
            end
        end
    else
        nms = readlines(LFF_file)
        popfirst!(nms)
    end

    return nms
end




########################################
# UNEXPORTED FUNCTIONS
########################################
"""
parsefile(lines;kwargs...)

The workhorse function behind `readFamaFrench`.

`lines` is an `IO` 
`kwargs` are passed to `CSV.read`. Missing values (`-99.99` or `-999`) are replaced with `missing`.

Returns three pieces:

    - `tables::Vector{DataFrame}` - the extracted tables

    - `tablenotes::Vector{String}` - any notes to the 
    
    - `filenotes::String` - notes at the top of the file
"""
function parsefile(lines;kwargs...)
    csvopt = (missingstrings = ["-99.99","-999"],normalizenames = true,copycols = true,kwargs...)

    stringarray = readlines(lines,keep=true)
    striparray = strip.(stringarray)
    splits = split.(stringarray,",")
    ncol = maximum(length(s) for s in splits)

    trows = findall(s->length(s)==ncol,splits)
    breaks = findall(!isequal(1),diff(trows))
    nbreaks = length(breaks)
    ntables = nbreaks + 1

    tranges = Vector{UnitRange{Int64}}(undef,ntables)

    if ntables == 1
        tranges[1] = trows[1]:trows[end]
    else
        tranges[1] = trows[1]:trows[breaks[1]]
        tranges[ntables] = trows[breaks[end]+1]:trows[end]
        if ntables > 2
            for n in 2:ntables-1
                tranges[n] = trows[breaks[n-1]+1]:trows[breaks[n]]
            end
        end
    end
    allempty = findall(isempty,striparray)
    lastempty = [lastornothing(filter(x -> x < k,allempty)) for k in first.(tranges)]
    nameranges = [isnothing(lastempty[i]) ? nothing : range(lastempty[i],first(tranges[i])-1,step=1) for i in 1:ntables] 

    dfvec = Vector{DataFrame}(undef,ntables)
    for i in 1:ntables
        ios = IOBuffer(string(stringarray[tranges[i]]...))
        dfvec[i] = CSV.read(ios;csvopt...)
        rename!(dfvec[i],Symbol(first(names(dfvec[i]))) => :Date)
        close(ios)
    end
    if isnothing(first(nameranges))
        notestop = trows[1]-1
        tablenotes = [i==1 ? "" : string(striparray[nameranges[i]]...) for i in 1:ntables]
    else
        tablenotes = [string(striparray[nameranges[i]]...) for i in 1:ntables]
        notestop = first(lastempty)
    end
    filenotes = string(lines.name,"  \n",striparray[1:notestop]...)

    return dfvec,tablenotes,filenotes
end



"""
`pathtoFamaFrench(ffn)`

Generates the full web path to the file.
"""
pathtoFamaFrench(ffn) = joinpath(KFDLftp,string(ffn, "_CSV.zip"))




"""
lastornothing(x) = isempty(x) ? nothing : last(x)

A helper function.
"""
lastornothing(x) = isempty(x) ? nothing : last(x)



end # module
